#coding:utf-8
import re
c_dict={"primary_expression" : ["IDENTIFIER","CONSTANT","STRING_LITERAL","'(' expression ')'",],
"postfix_expression" : ["primary_expression","postfix_expression '[' expression ']'","postfix_expression '(' ')'","postfix_expression '(' argument_expression_list ')'","postfix_expression '.' IDENTIFIER","postfix_expression PTR_OP IDENTIFIER","postfix_expression INC_OP","postfix_expression DEC_OP",],
"argument_expression_list" : ["assignment_expression","argument_expression_list ',' assignment_expression",],
"unary_expression" : ["postfix_expression","INC_OP unary_expression","DEC_OP unary_expression","unary_operator cast_expression","SIZEOF unary_expression","SIZEOF '(' type_name ')'",],
"unary_operator" : ["'&'","'*'","'+'","'-'","'~'","'!'",],
"cast_expression" : ["unary_expression","'(' type_name ')' cast_expression",],
"multiplicative_expression" : ["cast_expression","multiplicative_expression '*' cast_expression","multiplicative_expression '/' cast_expression","multiplicative_expression '%' cast_expression",],
"additive_expression" : ["multiplicative_expression","additive_expression '+' multiplicative_expression","additive_expression '-' multiplicative_expression",],
"shift_expression" : ["additive_expression","shift_expression LEFT_OP additive_expression","shift_expression RIGHT_OP additive_expression",],
"relational_expression" : ["shift_expression","relational_expression '<' shift_expression","relational_expression '>' shift_expression","relational_expression LE_OP shift_expression","relational_expression GE_OP shift_expression",],
"equality_expression" : ["relational_expression","equality_expression EQ_OP relational_expression","equality_expression NE_OP relational_expression",],
"and_expression" : ["equality_expression","and_expression '&' equality_expression",],
"exclusive_or_expression" : ["and_expression","exclusive_or_expression '^' and_expression",],
"inclusive_or_expression" : ["exclusive_or_expression","inclusive_or_expression '","' exclusive_or_expression",],
"logical_and_expression" : ["inclusive_or_expression","logical_and_expression AND_OP inclusive_or_expression",],
"logical_or_expression" : ["logical_and_expression","logical_or_expression OR_OP logical_and_expression",],
"conditional_expression" : ["logical_or_expression","logical_or_expression '?' expression '",],
"assignment_expression" : ["conditional_expression","unary_expression assignment_operator assignment_expression",],
"assignment_operator" : ["'='","MUL_ASSIGN","DIV_ASSIGN","MOD_ASSIGN","ADD_ASSIGN","SUB_ASSIGN","LEFT_ASSIGN","RIGHT_ASSIGN","AND_ASSIGN","XOR_ASSIGN","OR_ASSIGN",],
"expression" : ["assignment_expression","expression ',' assignment_expression",],
"constant_expression" : ["conditional_expression",],
"declaration" : ["declaration_specifiers ';'","declaration_specifiers init_declarator_list ';'",],
"declaration_specifiers" : ["storage_class_specifier","storage_class_specifier declaration_specifiers","type_specifier","type_specifier declaration_specifiers","type_qualifier","type_qualifier declaration_specifiers",],
"init_declarator_list" : ["init_declarator","init_declarator_list ',' init_declarator",],
"init_declarator" : ["declarator","declarator '=' initializer",],
"storage_class_specifier" : ["TYPEDEF","EXTERN","STATIC","AUTO","REGISTER",],
"type_specifier" : ["VOID","CHAR","SHORT","INT","LONG","FLOAT","DOUBLE","SIGNED","UNSIGNED","struct_or_union_specifier","enum_specifier","TYPE_NAME",],
"struct_or_union_specifier" : ["struct_or_union IDENTIFIER '{' struct_declaration_list '}'","struct_or_union '{' struct_declaration_list '}'","struct_or_union IDENTIFIER",],
"struct_or_union" : ["STRUCT","UNION",],
"struct_declaration_list" : ["struct_declaration","struct_declaration_list struct_declaration",],
"struct_declaration" : ["specifier_qualifier_list struct_declarator_list ';'",],
"specifier_qualifier_list" : ["type_specifier specifier_qualifier_list","type_specifier","type_qualifier specifier_qualifier_list","type_qualifier",],
"struct_declarator_list" : ["struct_declarator","struct_declarator_list ',' struct_declarator",],
"struct_declarator" : ["declarator","'",],
"enum_specifier" : ["ENUM '{' enumerator_list '}'","ENUM IDENTIFIER '{' enumerator_list '}'","ENUM IDENTIFIER",],
"enumerator_list" : ["enumerator","enumerator_list ',' enumerator",],
"enumerator" : ["IDENTIFIER","IDENTIFIER '=' constant_expression",],
"type_qualifier" : ["CONST","VOLATILE",],
"declarator" : ["pointer direct_declarator","direct_declarator",],
"direct_declarator" : ["IDENTIFIER","'(' declarator ')'","direct_declarator '[' constant_expression ']'","direct_declarator '[' ']'","direct_declarator '(' parameter_type_list ')'","direct_declarator '(' identifier_list ')'","direct_declarator '(' ')'",],
"pointer" : ["'*'","'*' type_qualifier_list","'*' pointer","'*' type_qualifier_list pointer",],
"type_qualifier_list" : ["type_qualifier","type_qualifier_list type_qualifier",],
"parameter_type_list" : ["parameter_list","parameter_list ',' ELLIPSIS",],
"parameter_list" : ["parameter_declaration","parameter_list ',' parameter_declaration",],
"parameter_declaration" : ["declaration_specifiers declarator","declaration_specifiers abstract_declarator","declaration_specifiers",],
"identifier_list" : ["IDENTIFIER","identifier_list ',' IDENTIFIER",],
"type_name" : ["specifier_qualifier_list","specifier_qualifier_list abstract_declarator",],
"abstract_declarator" : ["pointer","direct_abstract_declarator","pointer direct_abstract_declarator",],
"direct_abstract_declarator" : ["'(' abstract_declarator ')'","'[' ']'","'[' constant_expression ']'","direct_abstract_declarator '[' ']'","direct_abstract_declarator '[' constant_expression ']'","'(' ')'","'(' parameter_type_list ')'","direct_abstract_declarator '(' ')'","direct_abstract_declarator '(' parameter_type_list ')'",],
"initializer" : ["assignment_expression","'{' initializer_list '}'","'{' initializer_list ',' '}'",],
"initializer_list" : ["initializer","initializer_list ',' initializer",],
"statement" : ["labeled_statement","compound_statement","expression_statement","selection_statement","iteration_statement","jump_statement",],
"labeled_statement" : ["IDENTIFIER '",],
"compound_statement" : ["'{' '}'","'{' statement_list '}'","'{' declaration_list '}'","'{' declaration_list statement_list '}'",],
"declaration_list" : ["declaration","declaration_list declaration",],
"statement_list" : ["statement","statement_list statement",],
"expression_statement" : ["';'","expression ';'",],
"selection_statement" : ["IF '(' expression ')' statement","IF '(' expression ')' statement ELSE statement","SWITCH '(' expression ')' statement",],
"iteration_statement" : ["WHILE '(' expression ')' statement","DO statement WHILE '(' expression ')' ';'","FOR '(' expression_statement expression_statement ')' statement","FOR '(' expression_statement expression_statement expression ')' statement",],
"jump_statement" : ["GOTO IDENTIFIER ';'","CONTINUE ';'","BREAK ';'","RETURN ';'","RETURN expression ';'",],
"translation_unit" : ["external_declaration","translation_unit external_declaration",],
"external_declaration" : ["function_definition","declaration",],
"function_definition" : ["declaration_specifiers declarator declaration_list compound_statement","declaration_specifiers declarator compound_statement","declarator declaration_list compound_statement","declarator compound_statement	;",],


}

# c_dict={"init_declarator":['declarator', "declarator '=' initializer"],
# "jump_statement":["CONTINUE ';'", "BREAK ';'", "RETURN ';'", "RETURN expression ';'", ''],
# "1006":['type_qualifier 1006'],
# "1009":['statement 1009'],
# "logical_and_expression":['inclusive_or_expression 1000'],
# "external_declaration":['function_definition', 'declaration'],
# "expression_statement":["';'", "expression ';'"],
# "iteration_statement":["WHILE '(' expression ')' statement", "FOR '(' expression_statement expression_statement ')' statement", "FOR '(' expression_statement expression_statement expression ')' statement"],
# "function_definition":['type_specifier declarator compound_statement'],
# "parameter_list":['parameter_declaration 1001'],
# "multiplicative_expression":['cast_expression 1002'],
# "argument_expression_list":['assignment_expression 1003'],
# "relational_expression":['shift_expression 1004'],
# "type_specifier":['VOID', 'CHAR', 'INT', 'FLOAT'],
# "assignment_expression":['unary_expression assignment_operator assignment_expression', 'conditional_expression'],
# "constant_expression":['conditional_expression'],
# "shift_expression":['additive_expression 1005'],
# "1008":["' 1008"],
# "direct_declarator":["IDENTIFIER '(' ')' direct_declarator1", "IDENTIFIER '(' parameter_list ')' direct_declarator1", 'IDENTIFIER direct_declarator1'],
# "struct_or_union":['STRUCT', 'UNION'],
# "selection_statement":["IF '(' expression ')' statement", "IF '(' expression ')' statement ELSE statement"],
# "type_qualifier_list":['type_qualifier 1006'],
# "struct_declarator":['declarator', "':' constant_expression", "declarator ':' constant_expression"],
# "direct_abstract_declarator":["'(' abstract_declarator ')' 1007", "'[' ']' 1007", "'[' constant_expression ']' 1007", "'(' ')' 1007", "'(' parameter_type_list ')' 1007"],
# "inclusive_or_expression":['exclusive_or_expression 1008', "' exclusive_or_expression 1008"],
# "Enumerator":['IDENTIFIER', "IDENTIFIER '=' constant_expression"],
# "1015":["'[' expression ']' 1015", "'(' ')' 1015", "'(' argument_expression_list ')' 1015", "'.' IDENTIFIER 1015", 'PTR_OP IDENTIFIER 1015', 'INC_OP 1015', 'DEC_OP 1015'],
# "unary_operator":["'&'", "'*'", "'+'", "'-'", "'~'", "'!'"],
# "1012":['declaration 1012'],
# "1004":["'<' shift_expression 1004", "'>' shift_expression 1004", 'LE_OP shift_expression 1004', 'GE_OP shift_expression 1004'],
# "statement_list":['statement 1009'],
# "initializer":['unary_expression assignment_operator assignment_expression', 'conditional_expression'],
# "compound_statement":["'{' '}'", "'{' statement_list '}'", "'{' declaration_list statement_list '}'"],
# "parameter_type_list":['parameter_declaration 1001'],
# "additive_expression":['cast_expression 1002'],
# "1014":['struct_declaration 1014'],
# "1001":["',' parameter_declaration 1001"],
# "program":['VOID  declarator compound_statement', 'CHAR  declarator compound_statement', 'INT  declarator compound_statement', 'FLOAT  declarator compound_statement'],
# "exclusive_or_expression":['and_expression 1010'],
# "expression":['unary_expression assignment_operator assignment_expression', 'conditional_expression'],
# "type_qualifier":['CONST', 'VOLATILE'],
# "1002":["'*' cast_expression 1002", "'/' cast_expression 1002", "'%' cast_expression 1002"],
# "enumerator_list":['enumerator 1011'],
# "direct_declarator1":["'[' ']' direct_declarator1", "'[' constant_expression ']' direct_declarator1", "','  identifier_list direct_declarator1", ''],
# "equality_expression":['cast_expression 1002  1005  1004'],
# "type_name":['specifier_qualifier_list', 'specifier_qualifier_list abstract_declarator'],
# "labeled_statement":["IDENTIFIER ':' statement", "CASE constant_expression ':' statement", "DEFAULT ':' statement"],
# "declaration_list":['declaration 1012'],
# "struct_declarator_list":['declarator', "':' constant_expression", "declarator ':' constant_expression"],
# "enum_specifier":["ENUM '{' enumerator_list '}'", "ENUM IDENTIFIER '{' enumerator_list '}'", 'ENUM IDENTIFIER'],
# "identifier_list":['IDENTIFIER 1013'],
# "statement":["CONTINUE ';'", "BREAK ';'", "RETURN ';'", "RETURN expression ';'", ''],
# "assignment_operator":["'='", 'MUL_ASSIGN', 'DIV_ASSIGN', 'MOD_ASSIGN', 'ADD_ASSIGN', 'SUB_ASSIGN', 'LEFT_ASSIGN', 'RIGHT_ASSIGN', 'AND_ASSIGN', 'XOR_ASSIGN', 'OR_ASSIGN'],
# "1010":["'^' and_expression 1010"],
# "1013":["',' IDENTIFIER 1013"],
# "conditional_expression":['logical_or_expression', "logical_or_expression '?' expression ':' conditional_expression"],
# "and_expression":['cast_expression 1002  1005  1004'],
# "parameter_declaration":['declaration_specifiers  IDENTIFIER'],
# "1007":["'[' ']' 1007", "'[' constant_expression ']' 1007", "'(' ')' 1007", "'(' parameter_type_list ')' 1007"],
# "declaration":['declarator', "declarator '=' initializer"],
# "cast_expression":['unary_expression', "'(' type_name ')' cast_expression"],
# "Pointer":["'*'", "'*' pointer"],
# "struct_declaration_list":['struct_declaration 1014'],
# "1000":['AND_OP inclusive_or_expression 1000'],
# "specifier_qualifier_list":['VOID  specifier_qualifier_list', 'CHAR  specifier_qualifier_list', 'INT  specifier_qualifier_list', 'FLOAT  specifier_qualifier_list'],
# "postfix_expression":['primary_expression 1015'],
# "1003":["',' assignment_expression 1003"],
# "struct_declaration":["VOID  specifier_qualifier_list  struct_declarator_list ';'", "CHAR  specifier_qualifier_list  struct_declarator_list ';'", "INT  specifier_qualifier_list  struct_declarator_list ';'", "FLOAT  specifier_qualifier_list  struct_declarator_list ';'"],
# "primary_expression":['IDENTIFIER', 'CONSTANT', 'STRING_LITERAL', "'(' expression ')'"],
# "1011":["',' enumerator 1011"],
# "storage_class_specifier":['TYPEDEF', 'EXTERN', 'STATIC', 'AUTO', 'REGISTER'],
# "declarator":["IDENTIFIER '(' ')' direct_declarator1", "IDENTIFIER '(' parameter_list ')' direct_declarator1", 'IDENTIFIER direct_declarator1'],
# "1005":['LEFT_OP additive_expression 1005', 'RIGHT_OP additive_expression 1005'],
# "initializer_list":['logical_or_expression', "logical_or_expression '?' expression ':' conditional_expression"],
# "logical_or_expression":['unary_expression  1002  1005  1004  1010  1008  1000', "'(' type_name ')' cast_expression  1002  1005  1004  1010  1008  1000"],
# "abstract_declarator":["'(' abstract_declarator ')' 1007", "'[' ']' 1007", "'[' constant_expression ']' 1007", "'(' ')' 1007", "'(' parameter_type_list ')' 1007"],
# "unary_expression":["'&'  cast_expression", "'*'  cast_expression", "'+'  cast_expression", "'-'  cast_expression", "'~'  cast_expression", "'!'  cast_expression"],
# "struct_or_union_specifier":["STRUCT  IDENTIFIER '{' struct_declaration_list '}'", "UNION  IDENTIFIER '{' struct_declaration_list '}'"],
# }

def main():
    global c_dict
    num=0
    for key in c_dict.keys():
        print(key+"   "+ str(is_need_change(key)))
        if is_need_change(key):
            num+=1
    print(num)

def is_need_change(key):
    global c_dict
    derive_sentence_list=c_dict[key]
    for derive_sentence in derive_sentence_list:
        if derive_sentence.startswith(key):
            return True
        else:
            continue
    return False

if __name__ == '__main__':
	main()