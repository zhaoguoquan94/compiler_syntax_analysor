#coding:utf-8
import re
c_dict={"program" : ["external_declaration","program external_declaration",],
"external_declaration" : ["function_definition","declaration",],
"function_definition" : ["type_specifier declarator compound_statement",],
"type_specifier" : ["VOID","CHAR","INT","FLOAT",],
"declarator" : ["pointer direct_declarator","direct_declarator",],
"Pointer" : ["'*'","'*' pointer",],
# "direct_declarator" : ["IDENTIFIER '(' parameter_list ')'","IDENTIFIER '(' ')'","IDENTIFIER",],
"direct_declarator" : ["IDENTIFIER '(' ')' direct_declarator1","IDENTIFIER '(' parameter_list ')' direct_declarator1","IDENTIFIER direct_declarator1"],
"direct_declarator1":["'[' ']' direct_declarator1","'[' constant_expression ']' direct_declarator1","','  identifier_list direct_declarator1",""],
"identifier_list" : ["IDENTIFIER","identifier_list ',' IDENTIFIER",],
"constant_expression" : ["conditional_expression",],
"parameter_list" : ["parameter_declaration","parameter_list ',' parameter_declaration",],
"parameter_declaration" : ["declaration_specifiers  IDENTIFIER",],
"compound_statement" : ["'{' '}'","'{' statement_list '}'","'{' declaration_list statement_list '}'",],
"declaration_list" : ["declaration","declaration_list declaration",],
"declaration" : ["init_declarator","init_declarator_list ',' init_declarator",],
"init_declarator" : ["declarator","declarator '=' initializer",],
"initializer" : ["assignment_expression","'{' initializer_list '}'","'{' initializer_list ',' '}'",],
"initializer_list" : ["initializer","initializer_list ',' initializer",],
"statement_list" : ["statement","statement_list statement",],
"statement" : ["expression_statement","selection_statement","iteration_statement","jump_statement","compound_statement",""],
"expression_statement" : ["';'","expression ';'",],
"selection_statement" : ["IF '(' expression ')' statement","IF '(' expression ')' statement ELSE statement",],
"iteration_statement" : ["WHILE '(' expression ')' statement","FOR '(' expression_statement expression_statement ')' statement","FOR '(' expression_statement expression_statement expression ')' statement",],
"jump_statement" : ["CONTINUE ';'","BREAK ';'","RETURN ';'","RETURN expression ';'","",],
"expression" : ["assignment_expression","expression ',' assignment_expression",],
"assignment_expression" : ["unary_expression assignment_operator assignment_expression","conditional_expression",],
"conditional_expression" : ["logical_or_expression","logical_or_expression '?' expression ':' conditional_expression",],
"logical_or_expression" : ["logical_and_expression","logical_or_expression OR_OP logical_and_expression",],
"logical_and_expression" : ["inclusive_or_expression","logical_and_expression AND_OP inclusive_or_expression",],
"inclusive_or_expression" : ["exclusive_or_expression","inclusive_or_expression '","' exclusive_or_expression",],
"exclusive_or_expression" : ["and_expression","exclusive_or_expression '^' and_expression",],
"and_expression" : ["equality_expression","and_expression '&' equality_expression",],
"equality_expression" : ["relational_expression","equality_expression EQ_OP relational_expression","equality_expression NE_OP relational_expression",],
"relational_expression" : ["shift_expression","relational_expression '<' shift_expression","relational_expression '>' shift_expression","relational_expression LE_OP shift_expression","relational_expression GE_OP shift_expression",],
"shift_expression" : ["additive_expression","shift_expression LEFT_OP additive_expression","shift_expression RIGHT_OP additive_expression",],
"additive_expression" : ["multiplicative_expression","additive_expression '+' multiplicative_expression","additive_expression '-' multiplicative_expression",],
"multiplicative_expression" : ["cast_expression","multiplicative_expression '*' cast_expression","multiplicative_expression '/' cast_expression","multiplicative_expression '%' cast_expression",],
"cast_expression" : ["unary_expression","'(' type_name ')' cast_expression",],
"unary_expression" : ["postfix_expression","INC_OP unary_expression","DEC_OP unary_expression","unary_operator cast_expression","SIZEOF unary_expression","SIZEOF '(' type_name ')'",],
"postfix_expression" : ["primary_expression","postfix_expression '[' expression ']'","postfix_expression '(' ')'","postfix_expression '(' argument_expression_list ')'","postfix_expression '.' IDENTIFIER","postfix_expression PTR_OP IDENTIFIER","postfix_expression INC_OP","postfix_expression DEC_OP",],
"primary_expression" : ["IDENTIFIER","CONSTANT","STRING_LITERAL","'(' expression ')'",],
"argument_expression_list" : ["assignment_expression","argument_expression_list ',' assignment_expression",],
"unary_operator" : ["'&'","'*'","'+'","'-'","'~'","'!'",],
"assignment_operator" : ["'='","MUL_ASSIGN","DIV_ASSIGN","MOD_ASSIGN","ADD_ASSIGN","SUB_ASSIGN","LEFT_ASSIGN","RIGHT_ASSIGN","AND_ASSIGN","XOR_ASSIGN","OR_ASSIGN",],
"storage_class_specifier" : ["TYPEDEF","EXTERN","STATIC","AUTO","REGISTER",],
"struct_or_union_specifier" : ["struct_or_union IDENTIFIER '{' struct_declaration_list '}'","struct_or_union '{' struct_declaration_list '}'","struct_or_union IDENTIFIER",],
"struct_or_union" : ["STRUCT","UNION",],
"struct_declaration_list" : ["struct_declaration","struct_declaration_list struct_declaration",],
"struct_declaration" : ["specifier_qualifier_list struct_declarator_list ';'",],
"specifier_qualifier_list" : ["type_specifier specifier_qualifier_list","type_specifier","type_qualifier specifier_qualifier_list","type_qualifier",],
"struct_declarator_list" : ["struct_declarator","struct_declarator_list ',' struct_declarator",],
"struct_declarator" : ["declarator","':' constant_expression","declarator ':' constant_expression",],
"enum_specifier" : ["ENUM '{' enumerator_list '}'","ENUM IDENTIFIER '{' enumerator_list '}'","ENUM IDENTIFIER",],
"enumerator_list" : ["enumerator","enumerator_list ',' enumerator",],
"Enumerator" : ["IDENTIFIER","IDENTIFIER '=' constant_expression",],
"type_qualifier" : ["CONST","VOLATILE",],
"type_qualifier_list" : ["type_qualifier","type_qualifier_list type_qualifier",],
"parameter_type_list" : ["parameter_list","parameter_list ',' ELLIPSIS",],
"parameter_list" : ["parameter_declaration","parameter_list ',' parameter_declaration",],
"type_name" : ["specifier_qualifier_list","specifier_qualifier_list abstract_declarator",],
"abstract_declarator" : ["pointer","direct_abstract_declarator","pointer direct_abstract_declarator",],
"direct_abstract_declarator" : ["'(' abstract_declarator ')'","'[' ']'","'[' constant_expression ']'","direct_abstract_declarator '[' ']'","direct_abstract_declarator '[' constant_expression ']'","'(' ')'","'(' parameter_type_list ')'","direct_abstract_declarator '(' ')'","direct_abstract_declarator '(' parameter_type_list ')'",],
"labeled_statement" : ["IDENTIFIER ':' statement","CASE constant_expression ':' statement","DEFAULT ':' statement",]

}

c_dict={
"type_qualifier_list":['type_qualifier 1000'],
"struct_or_union_specifier":["struct_or_union IDENTIFIER '{' struct_declaration_list '}'", "struct_or_union '{' struct_declaration_list '}'", 'struct_or_union IDENTIFIER'],
"Enumerator":['IDENTIFIER', "IDENTIFIER '=' constant_expression"],
"type_specifier":['VOID', 'CHAR', 'INT', 'FLOAT'],
"enum_specifier":["ENUM '{' enumerator_list '}'", "ENUM IDENTIFIER '{' enumerator_list '}'", 'ENUM IDENTIFIER'],
"statement_list":['statement 1001'],
"expression_statement":["';'", "expression ';'"],
"shift_expression":['additive_expression 1002'],
"1003":['struct_declaration 1003'],
"external_declaration":['function_definition', 'declaration'],
"declaration":['init_declarator', "init_declarator_list ',' init_declarator"],
"1000":['type_qualifier 1000'],
"struct_declaration_list":['struct_declaration 1003'],
"1004":['AND_OP inclusive_or_expression 1004'],
"selection_statement":["IF '(' expression ')' statement", "IF '(' expression ')' statement ELSE statement"],
"primary_expression":['IDENTIFIER', 'CONSTANT', 'STRING_LITERAL', "'(' expression ')'"],
"logical_and_expression":['inclusive_or_expression 1004'],
"1002":['LEFT_OP additive_expression 1002', 'RIGHT_OP additive_expression 1002'],
"function_definition":['VOID  declarator compound_statement', 'CHAR  declarator compound_statement', 'INT  declarator compound_statement', 'FLOAT  declarator compound_statement'],
"1014":['EQ_OP relational_expression 1014', 'NE_OP relational_expression 1014'],
"specifier_qualifier_list":['VOID  specifier_qualifier_list', 'CHAR  specifier_qualifier_list', 'INT  specifier_qualifier_list', 'FLOAT  specifier_qualifier_list'],
"initializer_list":['initializer 1005'],
"init_declarator":['declarator', "declarator '=' initializer"],
"labeled_statement":["IDENTIFIER ':' statement", "CASE constant_expression ':' statement", "DEFAULT ':' statement"],
"1005":["',' initializer 1005"],
"identifier_list":['IDENTIFIER 1006'],
"struct_declarator_list":['struct_declarator 1007'],
"1013":["' 1013"],
"program":['declarator', "declarator '=' initializer"],
"1011":["'[' ']' 1011", "'[' constant_expression ']' 1011", "'(' ')' 1011", "'(' parameter_type_list ')' 1011"],
"statement":["';'", "expression ';'"],
"parameter_declaration":['declarator  _specifiers  IDENTIFIER', "declarator '=' initializer  _specifiers  IDENTIFIER"],
"conditional_expression":['logical_or_expression', "logical_or_expression '?' expression ':' conditional_expression"],
"unary_expression":['postfix_expression', 'INC_OP unary_expression', 'DEC_OP unary_expression', 'unary_operator cast_expression', 'SIZEOF unary_expression', "SIZEOF '(' type_name ')'"],
"type_name":['VOID  specifier_qualifier_list', 'CHAR  specifier_qualifier_list', 'INT  specifier_qualifier_list', 'FLOAT  specifier_qualifier_list'],
"struct_declaration":["VOID  specifier_qualifier_list  struct_declarator_list ';'", "CHAR  specifier_qualifier_list  struct_declarator_list ';'", "INT  specifier_qualifier_list  struct_declarator_list ';'", "FLOAT  specifier_qualifier_list  struct_declarator_list ';'"],
"cast_expression":['postfix_expression', 'INC_OP unary_expression', 'DEC_OP unary_expression', 'unary_operator cast_expression', 'SIZEOF unary_expression', "SIZEOF '(' type_name ')'"],
"and_expression":['equality_expression 1008'],
"struct_or_union":['STRUCT', 'UNION'],
"initializer":['assignment_expression', "'{' initializer_list '}'", "'{' initializer_list ',' '}'"],
"declarator":['pointer direct_declarator', 'direct_declarator'],
"enumerator_list":['enumerator 1009'],
"additive_expression":['multiplicative_expression 1010'],
"1012":["',' assignment_expression 1012"],
"direct_abstract_declarator":["'(' abstract_declarator ')' 1011", "'[' ']' 1011", "'[' constant_expression ']' 1011", "'(' ')' 1011", "'(' parameter_type_list ')' 1011"],
"1001":['statement 1001'],
"argument_expression_list":['assignment_expression 1012'],
"direct_declarator":["IDENTIFIER '(' ')' direct_declarator1", "IDENTIFIER '(' parameter_list ')' direct_declarator1", 'IDENTIFIER direct_declarator1'],
"Pointer":["'*'", "'*' pointer"],
"assignment_expression":['logical_or_expression', "logical_or_expression '?' expression ':' conditional_expression"],
"abstract_declarator":["'(' abstract_declarator ')' 1011", "'[' ']' 1011", "'[' constant_expression ']' 1011", "'(' ')' 1011", "'(' parameter_type_list ')' 1011"],
"logical_or_expression":['inclusive_or_expression 1004'],
"constant_expression":['logical_or_expression', "logical_or_expression '?' expression ':' conditional_expression"],
"multiplicative_expression":['postfix_expression', 'INC_OP unary_expression', 'DEC_OP unary_expression', 'unary_operator cast_expression', 'SIZEOF unary_expression', "SIZEOF '(' type_name ')'"],
"unary_operator":["'&'", "'*'", "'+'", "'-'", "'~'", "'!'"],
"assignment_operator":["'='", 'MUL_ASSIGN', 'DIV_ASSIGN', 'MOD_ASSIGN', 'ADD_ASSIGN', 'SUB_ASSIGN', 'LEFT_ASSIGN', 'RIGHT_ASSIGN', 'AND_ASSIGN', 'XOR_ASSIGN', 'OR_ASSIGN'],
"inclusive_or_expression":['exclusive_or_expression 1013', "' exclusive_or_expression 1013"],
"struct_declarator":["IDENTIFIER '(' ')' direct_declarator1", "IDENTIFIER '(' parameter_list ')' direct_declarator1", 'IDENTIFIER direct_declarator1'],
"declaration_list":["IDENTIFIER '(' ')' direct_declarator1", "IDENTIFIER '(' parameter_list ')' direct_declarator1", 'IDENTIFIER direct_declarator1'],
"type_qualifier":['CONST', 'VOLATILE'],
"parameter_type_list":['parameter_list', "parameter_list ',' ELLIPSIS"],
"1009":["',' enumerator 1009"],
"postfix_expression":['IDENTIFIER', 'CONSTANT', 'STRING_LITERAL', "'(' expression ')'"],
"iteration_statement":["WHILE '(' expression ')' statement", "FOR '(' expression_statement expression_statement ')' statement", "FOR '(' expression_statement expression_statement expression ')' statement"],
"parameter_list":["IDENTIFIER '(' ')' direct_declarator1    _specifiers  IDENTIFIER", "IDENTIFIER '(' parameter_list ')' direct_declarator1    _specifiers  IDENTIFIER", 'IDENTIFIER direct_declarator1    _specifiers  IDENTIFIER'],
"expression":['exclusive_or_expression 1013  1004', "' exclusive_or_expression 1013  1004"],
"equality_expression":['relational_expression 1014'],
"exclusive_or_expression":['equality_expression 1008'],
"storage_class_specifier":['TYPEDEF', 'EXTERN', 'STATIC', 'AUTO', 'REGISTER'],
"1008":["'&' equality_expression 1008"],
"1006":["',' IDENTIFIER 1006"],
"1007":["',' struct_declarator 1007"],
"relational_expression":["'&'  cast_expression  1010  1002", "'*'  cast_expression  1010  1002", "'+'  cast_expression  1010  1002", "'-'  cast_expression  1010  1002", "'~'  cast_expression  1010  1002", "'!'  cast_expression  1010  1002"],
"compound_statement":["'{' '}'", "'{' statement_list '}'", "'{' declaration_list statement_list '}'"],
"jump_statement":["CONTINUE ';'", "BREAK ';'", "RETURN ';'", "RETURN expression ';'", ''],
"direct_declarator1":["'[' ']' direct_declarator1", "'[' constant_expression ']' direct_declarator1", "','  identifier_list direct_declarator1", ''],
"1010":["'+' multiplicative_expression 1010", "'-' multiplicative_expression 1010"]
}

def main():
    global c_dict
    num=0
    for key in c_dict.keys():
        print(key+"   "+ str(is_need_change(key)))
        if is_need_change(key):
            num+=1
    print(num)

def is_need_change(key):
    global c_dict
    derive_sentence_list=c_dict[key]
    for derive_sentence in derive_sentence_list:
        if derive_sentence.startswith(key):
            return True
        else:
            continue
    return False

if __name__ == '__main__':
	main()